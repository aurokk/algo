// -- ТЕСТЫ --
// https://contest.yandex.ru/contest/25597/run-report/66722050/
// 
// -- ПРИНЦИП РАБОТЫ -- 
// Решение методом динамического программирования
// 1. В элементах массива dp хранится текущее расстояние по Левинштейну, для строк длиной i и j
// 2. Базовый случай — когда одна из строк длины 0, тогда расстояние по Левинштейну равно длине второй строки
// 3. Переход динамики будет таким берем минимальное из элементов
//      выше dp[i-1][j] + 1,
//      слева dp[i][j-1],
//      и по-диагонали dp[i-1][j-1] + (если символы a[i] b[j] не совпали, то прибавляем единицу)
// 4. Порядок вычисления — по возрастанию индекса
// 5. Ответ на исходный вопрос будет располагаться в последней ячейке dp[n][m]
// 
// -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
// Растояние между строками равно количеству изменений которые необходимо внести в любую из строк, чтобы получить вторую
// Так для строк
// a и a растояние равно 0, a == a,
// a и b растояние равно 1, нужно заменить одну из букв на другую a->b
// a и bb расстояние равно 2, нужно сделать две операции заменить a->b и добавить ещё символ b
// 
// База
// если первая строка пустая, то расстояние равно длине второй строки, например
// "" и "aaa" — расстояние равно 3, так как нужно сделать 3 операции добавления символа a, чтобы получить "aaa"
//
// Шаг
// значения при i=0 или j=0 мы знаем заранее, поэтому расчеты можно вести начиная с i=1, j=1
// чтобы вычислить значение d[i][j] мы опираемся на ранее вычисленные, dp[i-1][j], dp[i][j-1], dp[i-1][j-1]
// значение d[i][j] будет равно минимальному из
// dp[i-1][j]+1,
// dp[i][j-1]+1,
// dp[i-1][j-1]+1 если соответствующие символы a[i] и b[j] не равны,
// dp[i-1][j-1] если соответствующие символы a[i] и b[j] равны
// +1 тут означает, что расстояние увеличилось,
// если же мы берем одно из предыдущих значений, то значит не увеличилось
// 
// Вывод
// Таким образом на каждом шаге инвариант выполняется, мы имеем оптимальное значение и в конце получаем ответ
// 
// -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
// O(N*M) где N, количество букв в первом слов, M количество букв во втором
//
// -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
// O(N+M) где N, количество букв в первом слов, M количество букв во втором,
// Я храню первую строку длиной N, вторую строку длиной M и два массива длиной M, => N+3M => ~O(N+M)

using System;
using System.IO;

namespace A
{
    public static class A
    {
        private static StreamReader _reader;
        private static StreamWriter _writer;

        private static int Min(int a, int b, int c) =>
            Math.Min(Math.Min(a, b), c);

        public static void Main(string[] args)
        {
            _reader = new StreamReader(Console.OpenStandardInput());
            _writer = new StreamWriter(Console.OpenStandardOutput());

            var a = ReadString();
            var b = ReadString();

            // INIT
            var dp1 = new int[b.Length + 1];
            var dp2 = new int[b.Length + 1];

            // DP
            for (var i = 0; i < a.Length + 1; i++)
            {
                for (var j = 0; j < b.Length + 1; j++)
                {
                    if (i == 0 && j == 0)
                    {
                        dp2[j] = 0;
                        continue;
                    }

                    if (i == 0)
                    {
                        dp2[j] = dp2[j - 1] + 1;
                        continue;
                    }

                    if (j == 0)
                    {
                        dp2[j] = dp1[j] + 1;
                        continue;
                    }

                    dp2[j] = Min(
                        dp2[j - 1] + 1,
                        dp1[j] + 1,
                        dp1[j - 1] + (a[i - 1] == b[j - 1] ? 0 : 1));
                }

                for (var j = 0; j < b.Length + 1; j++)
                {
                    dp1[j] = dp2[j];
                    dp2[j] = 0;
                }
            }

            // WRITE ANSWER
            _writer.WriteLine(dp1[b.Length]);

            _reader.Close();
            _writer.Close();
        }

        private static string ReadString() =>
            _reader.ReadLine();
    }
}